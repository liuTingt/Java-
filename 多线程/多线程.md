# 基础概念

## 1、进程

​	进程是对某程序的运行过程，像运行QQ.exe，就是打开了一个进程。进程相对于程序来说它是一个动态的概念。

## 2、线程

​	线程是操作系统能够运算调度的最小单位，进程里面最小的执行单元。即一个程序里不同的执行路径就叫做一个线程。
​	线程状态有：初始（New）、运行状态（Runnable，包含就绪ready和运行中running）、阻塞状态（Blocked）、等待状态（Waiting）、超时等待状态（Time_Waiting）、终止状态（Terminated）

![img](https://images2018.cnblogs.com/blog/930824/201807/930824-20180715222029724-1669695888.jpg)

```
new MyThread().run();// run()方法是单线程执行
new MyThread().start();// start()方法是多线程执行
```

## 3、纤程

​	一个纤程包含多个纤程，纤程具有切换速度快的特点

## 4、线程中的方法

1）sleep(long millis)、sleep(long millis, int nanos)
	sleep()作用是让当前线程休眠，当前线程进入超时等待状态，休眠时间结束后，线程进入就绪状态，等待cpu的调度。
	sleep方法调用后让出cpu的执行权，但是没有释放锁。

2）join()、join(long millis)、join(long millis, int nanos)
	join()的作用是加入，它能够让调用该方法的线程加入到当前执行线程的前面。入在线程A中调用了线程B的join方法，则会立即执行线程B，等线程B执行完后才继续执行线程A。

3）yield()
	yield()的作用是让步，它能够让当前线程从运行状态进入就绪状态，从而让其他线程获取执行权。

## 2、锁的概念和特性

synchronized关键字，对某个对象加锁

```
public class T{
	private int count = 0;
	private Object o = new Object();
	
	public void m() {
		synchronized(o){// 任何线程要执行一下代码，必须拿到o的锁
			count++；
		}
	}
}
synchronized锁，锁定的是o对象，只有拿到o的锁，才能执行里面的代码。
```

锁定当前对象

```
public void m(){
	synchronized(this){
		print("");
	}
}
等同于以下代码
public synchronized void m() {
	print();
}
```

静态方法的synchronized方法，锁定的是当前类(T.class)

```
public class T{
    public synchronized static void m() {
        print();
    }
    等同于以下代码
    public static void m() {
        synchronized(T.class);
    }
}
```

**异常跟锁**
	程序在执行过程中，如果出现异常，默认情况锁会被释放。



## 2、方法

## 面试问题

### 1、线程启动的三种方式

1）继承Thread类

```
public MyThread extends Thread{
	public void run() {
		print("继承Thread");
	}
	
	public static void main(String[] args){
		MyThread t = new MyThread();
		t.start();
		// 使用lambda表达式
		new Thread(()->{
			print("lambda");
		}).start()
	}
}
```

2）实现Runnable接口

```
public class MyRunnable implements{
	public void run() {
		print("");
	}
	public static void main(String[] args){
		MyRunnable run = new MyRunnable();
		Thread t = new Thread(run);
		t.start();
	}
}
```

3）实现Callable接口
实现Callable接口，重写call()方法，该方法有返回值，并可以声明抛出异常,实现步骤如下

 *	1、实现Callable接口，重写call()方法
 *	2、创建Callable的实例，使用FutureTask来包装Callable对象
 *	3、使用FutureTask做为Thread类的target创建并启动线程
 *	4、调用FutureTask的get()方法，返回子线程执行结果的返回值

```
public class MyCallable implements Callable<String>{

	@Override
	public String call() throws Exception {
		System.out.println("执行。。。。");
		return "OK";
	}
	public static void main(String[] args) {
		Callable<String> myCallable = new MyCallable();
		// 创建FutureTask对象,
		FutureTask<String> task = new FutureTask<String>(myCallable);
		// FutureTask是包装器，它通过接收Callable来创建，同时实现了Future和Runnable接口
		Thread t = new Thread(task);
		t.start();
		try {
			String result = task.get();
			System.out.println(result);
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (ExecutionException e) {
			e.printStackTrace();
		}
	}
}
```

### 2、如何保证三个线程T1、T2、T3按照顺序执行？

使用join()方法即可保证

```
public static void main(String[] args) {
		
		Thread t1 = new Thread(()-> {
			System.out.println("t1");
		});
		
		final Thread t2 = new Thread(()-> {
			try {
				t1.join();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			System.out.println("t2");
		});
		
		final Thread t3 = new Thread(()-> {
			try {
				t2.join();
				
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			System.out.println("t3");
		});
		t2.start();
		t3.start();
		t1.start();
	}
```

### 3、sleep和wait有什么区别？

1）sleep是Thread的静态方法，到达休眠时间后自动进入就绪状态。
2）wait是object的方法，进入wait状态的线程只能使用notify和notifyAll方法唤醒线程。
3）wait方法会释放锁，但是sleep方法不会。
4）线程调用sleep后，线程状态为Time_Waiting状态，调用wait方法后，线程变为waiting状态。
5）wait必须搭配synchronize一起使用。

