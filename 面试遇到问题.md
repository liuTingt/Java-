# 20210409电面

## 项目中遇到的难点

分布式事务：

https://zhuanlan.zhihu.com/p/183753774





## eureka和zookeeper的区别

服务访问不到eureka怎么处理



## 多线程

线程之间共享变量可以使用volatile关键子，保证可见性和禁止重排序



## Lock和synchronized的区别

https://www.cnblogs.com/dolphin0520/p/3923167.html

synchronized是Java语言内置的一个特性，有以下缺陷：

一个代码块块被synchronized修饰，当一个线程获取了锁，在执行过程中，其他线程只能一直等待，等待获取锁的线程释放锁，synchronized释放锁有两种情况：

- 获取所得线程执行完了该代码块，线程释放对锁的占用
- 线程执行发生异常，此时JVM会让线程自动释放锁

如果这个获取锁的线程由于要等待IO或者其他（网络）原因被阻塞了，但是又没有释放锁，其他线程只能等待，这会影响程序执行效率。通过Lock可以手动释放锁。

1. Lock不是Java语言内置的，synchronized是Java语言的关键子，因此是内置特性，Lock是一个类，通过这个类可以实现同步访问。
2. synchronized在代码块执行完后，系统会自动让线程释放对锁的占用；Lock必须用户手动释放锁，如果没有主动释放锁，可能导致死锁现象。

### Lock锁

lock声明了四个方法来获取锁

1. void lock()：如果锁已经被其他线程获取，则进行等待。

   ```
   Lock lock = ...;
   lock.lock();
   try{
       //处理任务
   }catch(Exception ex){
        
   }finally{
       lock.unlock();   //释放锁
   }
   ```

   

2. boolean tryLock()：尝试获取锁，如果获取成功，则返回true，如果获取失败则返回false，也就是这个方法无论如何都会立即返回，拿不到锁时不会一直在哪等待。

3. Boolean tryLock(time)

   







springBoot的优点，配置文件的形式，yml形式包含那几个形式，springBoot如何启动，



加载bean过程



bean在注入的时候除了反射还有什么方式去找bean。

spring除了反射还有那种注解方式



Mybatis缓存



索引创建，失效场景





Redis在项目中的使用，如何部署的，哨兵机制，主从复制





Kafka是怎么产生和消费的，当消费失败怎么处理



对象直接放到老年代，采用了什么机制





线程池的参数，有几种创造线程池的方法



排查线上omm的工具，怎么定位到具体代码



# Java内存模型JMM

https://www.cnblogs.com/Scramblecode/p/11392639.html

Java内存模型的作用是用来屏蔽掉不同操作系统中的内存差异性来保持并发的一致性。同时JMM规范了JVM如何与计算机内存进行交互。简单说Java内存模型就是Java的一套协议来屏蔽各种硬件和操作系统的内存访问差异，实现平台一致性达到最终的“一次编写，到处运行”。

Java 内存模型是通过内存屏障来禁止重排序的。

JMM抽象示意图：

![img](面试遇到问题.assets/1673435-20190916094320422-373477991.png)

**多线程之间的通信和同步：**

线程之间的通信方式有两种，共享内存和消息传递。
**共享内存：**在共享内存方式的并发模型中线程是通过读取主内存的共享信息来进行隐性通信的；在共享内存中同步是显性进行的，在代码中必须要去指定方法需要同步执行比如加同步锁等。（堆内存中共享变量之间的通信）

**消息传递：**在消息传递通信中线程之间没有公共的状态，只能通过发送消息来进行显式通信；在消息传递的并发模型中发送消息必须在消息接收之前，所以同步时隐式的。（线程栈的不共享变量之间的通信）





静态变量是存在那个区域的？







cms，G1垃圾回收、垃圾回收算法、B+和红黑树、线程池状态、java为什么选择synchronize，有什么优势、 



线程的状态有哪些



如果多个线程要同时执行，怎么让多个线程先执行





# MyBatis中#和${}区别？

在MyBatis的映射配置文件中，动态传递参数有两种，#{}占位符，${}拼接符。

1. #{}是预编译处理（PreparedStatement）范畴的；${}是字符串替换。
2. 使用#{}可以有效地防止SQL注入，提高系统安全性；${}会导致SQL注入。
3. #{}的变量替换是在DBMS中；${}的变量替换是在动态解析过程中。
4. 变量替换后，#{}对应的变量会自动加上单引号''，${}对应的变量不会加上单引号''。

```
#{}：select * from t_user where uid=#{uid}
${}：select * from t_user where uid='${uid}'
(动态解析过程)传入参数uid为1，然后:
#{}：select * from t_user where uid= ?
${}：select * from t_user where uid= '1'
（DBMS中）最后：
#{}：select * from t_user where uid= '1'
${}：select * from t_user where uid= '1'
```



## 如果一条SQL中同时存在#和&，会先解析哪一个

在动态解析阶段的处理不同，在预处理的时候，#{}会把参数部分用一个占位符？代替；而${}则只是简单的字符串替换。

```
示例：select * from user where name=#{}
如果name值为张三，动态解析后为SQL语句：select * from user where name=?

select * from user where name=${}
如果name值为张三，动态解析后为：select * from user where name='张三'
```



## 什么情况下使用&

1、当表名用参数传递进来的时候，只能使用&{}，所以我们要小心SQL注入的问题。

```
示例：select * from ${tablename} where name=#{name}
如果传过来表名为user;delete user; --,则动态解析之后SQL如下：
select * from user;delete user; -- where name=?
```

2、MyBatis排序时使用order by动态参数时使用&



## 为什么表名和order by要使用${}

因为#{}在变量替换之后会自动加上单引号''，${}输出变量的值，没有单引号。



# spring AOP实现原理

采用横向抽取机制，底层使用动态代理



# Redis分布式锁





# 常用设计模式



# Spring创建对象是单例还是多例？如何创建多例

Spring默认创建的类是单例的，可以通过scope属性更改为多例，scope范围有：

singleton：单例

prototype：多例

```
XML配置文件：
<bean id="user" class="modle.User" scope="prototype">
  </bean>
注解形式：
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE) 可设置为多例
public class User {
}
  
```



# 单例模式

双重锁检查

```
public class SingletionClass {

	private static volatile SingletionClass singletionClass;
	
	private SingletionClass() {
		
	}
	
	public static SingletionClass getSingleton() {
		if(singletionClass == null) {
			synchronized (SingletionClass.class) {
				if(singletionClass == null) {
					singletionClass = new SingletionClass();
				}
			}
		}
		return singletionClass;
	}
}
```

## 如何破坏一个单例

单例模式一般都是通过私有化构造方法和静态变量。通过调用指定的public成员方法获取单例模式的对象。所以如果能够使用私有化的构造方法创建对象，就可以创建一个新的对象，即破坏了单例模式。

**使用反射机制破坏单例：**

1. 首先获取该单例的Class对象，通过调用该对象getDeclaredConstructors()方法，获取所有构造方法。
2. 设置构造方法的访问权限为true，调用Constructor的newInstance()方法，即可返回该单例的一个新对象，与原对象的地址不同。

```
public static void main(String[] args) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		SingletionClass t1 = SingletionClass.getSingleton();
		SingletionClass t2 = SingletionClass.getSingleton();
		System.out.println(t1);
		System.out.println(t2);
		System.out.println(t1 == t2);
		
		Class clazz = SingletionClass.class;
		Constructor[] cons = clazz.getDeclaredConstructors();
		Constructor constructor = cons[0];
		constructor.setAccessible(true);
		SingletionClass newIns = (SingletionClass)constructor.newInstance();
		System.out.println(newIns);
	}
	
	输出：
	com.example.demo.singleton.SingletionClass@15db9742
    com.example.demo.singleton.SingletionClass@15db9742
    true
    com.example.demo.singleton.SingletionClass@6d06d69c
```

​	



# SpringBoot的加载过程



启动是怎么加载的流程。。。。





# 发生oom怎么排查

**OutOfMemoryError**可能出现的错误消息：

- java.lang.OutOfMemoryError: Java heap space
- java.lang.OutOfMemoryError: PermGen space
- java.lang.OutOfMemoryError: Requested array size exceeds VM limit
- java.lang.OutOfMemoryError: request bytes for . Out of swap space?
- java.lang.OutOfMemoryError: (Native method)

https://www.cnblogs.com/c-xiaohai/p/12489336.html

1. **使用dmesg命令查看系统日志**

   dmesg |grep -E ‘kill|oom|out of memory’，可以查看操作系统启动后的系统日志，这里就是查看跟内存溢出相关联的系统日志。

2. **需要启动项目，使用ps命令查看进程**

   ps -aux|grep java 命令查看一下你的java进程，就可以找到你的java进程的进程id

3. **接着使用top命令，查看运行的进程的cpu负载、内存使用、所占资源等**

   top命令显示的结果列表中，会看到%MEM这一列，这里可以看到你的进程可能对内存的使用率特别高。以查看正在运行的进程和系统负载信息，包括cpu负载、内存使用、各个进程所占系统资源等。

   ![img](面试遇到问题.assets/top命令.png)

4. **使用jstat命令，打印Java堆的状况，包括新生代的两个S0、S1区、Eden区，以及老年代的内存使用率，还有Minor GC和Full GC的次数。**

   用jstat -gcutil 20886 1000 10命令，示每1000毫秒打印一次Java堆状况，打印10次，就是用jstat工具，对指定java进程（20886就是进程id，通过ps -aux | grep java命令就能找到），按照指定间隔，看一下统计信息，这里会每隔一段时间显示一下，包括新生代的两个S0、s1区、Eden区，以及老年代的内存使用率，还有young gc以及full gc的次数。

   通过jstat基本能看出来，其实就是大对象没法回收，一直在内存里占据着。

5. **使用jmap命令，可以打印出当前堆中所有每个类的实例数量和内存占用**

   执行jmap -histo pid可以打印出当前堆中所有每个类的实例数量和内存占用，如下，class name是每个类的类名（[B是byte类型，[C是char类型，[I是int类型），bytes是这个类的所有示例占用内存大小，instances是这个类的实例数量。

6. **使用jmap -dump:format=b,file=文件名 [pid]，把当前堆内存的快照转储到.hprof文件中**

   使用jmap -dump:format=b,file=文件名 [pid]，就可以把指定java进程的堆内存快照搞到一个指定的文件里去，但是jmap -dump:format其实一般会比较慢一些，也可以用gcore工具来导出内存快照。然后就可以使用MAT工具，来对hprof文件进行分析。或者使用jdk的目录下的bin目录下的：jvisualvm.exe



但是 JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。jconsole：用于对 JVM 中的内存、线程和类等进行监控；jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。



# AQS

https://blog.csdn.net/mulinsen77/article/details/84583716

AQS即AbstractQueuedSynchronizer，抽象的队列式同步器。是除了Java自带的synchronized关键字之外的锁，这个类在java.util.concurrent.locks包下。

AQS的核心思想就是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占有，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是使用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，即不存在队列实例，仅存在节点之间的关联关系，

**AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个节点，来实现锁的分配。**

用大白话说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。

**注意：**AQS是自旋锁。等待唤醒的时候，经常会使用自选的方式，不停的尝试获取锁，知道被其他线程获取成功。



# Kafka吞吐量高原因





# CMS和G1收集器区别

CMS收集器是并发的且基于标记-清除算法的，会**产生内存碎片**。它清理垃圾的步骤大致分为初始标记、并发标记、重新标记和并发清理。初始标记和重新标记会Stop The World，并发清理是保留上一步骤标记出的存活对象，清理掉其他对象，正是因为采用了并发清理，所以在清理过程中用户线程又会产生垃圾，而导致**浮动垃圾**，只能通过下次垃圾回收进行处理。

清理垃圾的步骤大致分为**初始标记、并发标记、重新标记和并发清理。**
CMS垃圾回收的内存模型还是我们常用的年轻代和老年代的结构；
CMS是基于标记-清除算法的，所以会产生内存碎片；
CMS的并发清理阶段，用户线程会产生垃圾，导致浮动垃圾，只能下次垃圾回收进行处理；
CMS收集器作用于回收老年代；

G1收集器回收垃圾的处理步骤大致为：**初始标记、并发标记、最终标记和筛选回收**。
G1收集器将堆空间划分为若干个等大的Region块，但还是保留了新生代、老年代的概念，但主要以Region为单位进行垃圾回收；
G1收集器是采用标记-整理算法，所以不会产生内存碎片；
G1最终的回收是STW的，所以不会产生浮动垃圾，Region的区域大小是固定的，所以回收时间也是可控的；
G1使用Remembered Set来避免全堆扫描；
G1适用在新生代和老年代；

|                          | **CMS**                      | **G1**                                                       |
| ------------------------ | ---------------------------- | ------------------------------------------------------------ |
| **JDK版本**              | 1.6以上                      | 1.7以上                                                      |
| **回收算法**             | 标记——清除                   | 标记——整理                                                   |
| **运行环境**             | 针对70G以内的堆内存          | 可针好几百G的大内存                                          |
| **回收区域**             | 老年代                       | 新生代和老年代                                               |
| **内存布局**             | 传统连续的新生代和老年代区域 | Region(将新生代和老年代切分成Region，默认一个Region 1 M,默认2048块) |
| **浮动垃圾**             | 是                           | 否                                                           |
| **内存碎片**             | 是                           | 否                                                           |
| **全堆扫描**             | 是                           | 否                                                           |
| **回收时间可控**         | 否                           | 是                                                           |
| **对象进入老年代的年龄** | 6                            | 15                                                           |
| **空间动态调整**         | 否                           | 是（新生代5%-60%动态调整，一般不需求指定）                   |
| **调优参数**             | 多（近百个）                 | 少（十几个）                                                 |

# 什么情况下对象直接进入老年代，使用什么机制

1. 当**分代年龄=-XX:MaxTenuringThreshold **指定的大小时，进入老年代；
2. **动态晋升机制**，根据**-XX:TargetSurvivorRatio**（默认50，即50%）指定的比例，乘以survive一个区的大小，得出**目标晋升空间大小**。然后将分代对象大小，按照分代年龄从小到大相加，**直到大于目标晋升空间大小**，然后，将得出的这个分代年龄以上的对象全部晋升到老年代。（例如：一个survive区的大小为100M，目标晋升空间=50M，对象按年龄从小到大排序，按照顺序把对象占用的空间相加，加到对象年龄=5的时候，对象占用空间>目标晋升空间，然后，将5岁以上的对象全部晋升到老年代）
3. 对于一些GC算法，可能直接在老年代上分配，例如G1 GC中的大对象分配，就是对象在超过Region一半大小的时候，直接在老年代的连续空间分配。

# 垃圾回收算法

### 标记清除算法



### 复制算法



### 标记整理算法



### 分代收集算法

堆内存分为年轻代和老年代。Java默认启动分代GC。

1. 新建对象分配到Eden区，Eden区内存不够时，触发Minor GC；
2. 经过Minor GC会使存活对象进入from区，年龄加1（from区和to区会交换引用地址）；
3. 当**分代年龄=-XX:MaxTenuringThreshold **指定的大小时，进入老年代；
4. **动态晋升机制**，根据**-XX:TargetSurvivorRatio**（默认50，即50%）指定的比例，乘以survive一个区的大小，得出**目标晋升空间大小**。然后将分代对象大小，按照分代年龄从小到大相加，**直到大于目标晋升空间大小**，然后，将得出的这个分代年龄以上的对象全部晋升到老年代。（例如：一个survive区的大小为100M，目标晋升空间=50M，对象按年龄从小到大排序，按照顺序把对象占用的空间相加，加到对象年龄=5的时候，对象占用空间>目标晋升空间，然后，将5岁以上的对象全部晋升到老年代）
5. 当老年代内存不够会触发Full GC，年轻代和老年代会一起进行垃圾回收，此时会触发SWT机制，造成程序的停顿。



创建的对象会分配到Eden区，当Eden区内存不够的时候，触发Minor GC，根据可达性分析算法将存活的对象进行标记，并移动到Survive的from区，同时将对象的年龄加1；此时Eden区有了空闲内存，新创建对象仍会在Eden区分配内存，当Eden区内存又满了之后，Eden区和from区存活的对象进入到to区，存活对象年龄加1，交换form和to区的引用，即此时存活对象在from中，to区保持空闲。如果from区中对象年龄达到阈值15（默认15）或者from区或to区达到整个对象的50%（此处整个对象是指Survive？），则存活对象进入到老年代，如果老年代内存不够用会触发Full GC，即新生代和老年代会一起进行垃圾回收，此时可能会触发SWT机制（stop-the-world），造成程序的停顿。



# 内存单薄？？？





# 为什么要有自定义加载器





# 双亲委派机制





# Redis分布式锁有什么缺点





# Eureka注册中心

eureka使用的是几级缓存，是因为缓存实现高可用的，使用了二层缓存

![Eureka](面试遇到问题.assets/Eureka.jpg)

Eureka作为服务注册中心，采用CS架构，Eureka提供服务注册和服务发现，包含服务注册中心（Eureka Server）、服务提供者（Service Provider）、服务消费者（Service Consumer）。

- Eureka Server：提供服务注册和发现，多个服务之间会同步数据，做到最终一致。
- Service Provider：将自身服务注册到Eureka
- Service Consumer：从Eureka获取注册服务列表，从而能够消费服务

**服务发现有两种模式：**一种是客户端发现模式，一种是服务端发现模式。Eureka采用的是客户端发现模式。

**服务注册：**

1. Eureka Client客户端启动后**Register**注册到Eureka Server服务端，并从服务端获取注册列表缓存在本地。
2. 客户端每隔一定周期（默认30s），向服务端发送心跳，这时Eureka的**Renew**（更新/续借）
3. 如果服务端在多个心跳周期（默认90s）没有收到客户端发送的心跳，服务端将会在服务注册列表中提出该节点。
4. 如果客户端停止应用，向服务端发送**Cancel**取消请求，服务端收到取消请求后，将客户端从服务注册列表中剔除。

**服务中心：**

1. 当各个微服务节点启动后，Eureka Server服务端会存储服务提供者注册上来的服务信息，并提供二层缓存机制来维护整个注册中心。
2. 如果服务端节点都宕掉，因为服务提供者本地缓存了服务注册列表，所以仍然可以找到服务提供者，但是会出现信息不一致。

**Eureka自我保护机制：**

使用自我保护机制能够使集群更加健壮稳定的运行。

自我保护机制是说，如果15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka Server认为客户端于注册中心发生了网络故障，Eureka Server进入自我保护机制。

**为什么要开启自我保护？**

如果Eureka Server在一定时间内（默认90s）没有收到客户端的心跳，会将客户端节点从服务注册列表中剔除，但是在某些时候，遇到网络分区故障，服务节点实际上是正常状态，但是无法和Server通信，如果没有引入自我保护机制，Server会将该服务节点剔除。

**自我保护机制缺点**

如果在自我保护机制中，刚好某些服务节点非正常下线，但是Eureka Server并不会剔除该服务节点，服务消费者就会获取到一个无效的服务实例。

**Eureka Server 进入自我保护机制后**

1. Eureka Server不在从注册表中剔除因为长时间没有和注册中心续约的服务。
2. Server仍能够接收新服务的注册和查询请求，但是不会同步到其他Server节点上。
3. 网络正常后，当前Server节点会将新的服务节点信息同步到其他Server节点上。

**如何开启自我保护**

eureka.server.enable-self-presercation=true/false 开启或关闭

**解除自我保护**

1. 当服务的网络分区故障接触后，客户端能够和服务端进行交互，在续约的时候，更新每分钟的续约数，当每分钟的续约数大于85%时，则自动解除。
2. 重启服务

**Eureka的健康检查**



**Eureka的重试机制**

Eureka实现的服务治理机制强调了CAP的AP，机可用性和分区容错性，牺牲了一定的一致性





Eureka多级缓存机制

# CAP理论

CAP理论是指一个分布式系统最多只能同时满足Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错）这三项中的两项。

![img](面试遇到问题.assets/CAP理论.jpeg)

## Consistency 一致性

一致性是指所有的节点在同一时间的数据完全一致。对于一致性，也可以从客户端和服务端两个不同的视角来理解。

**客户端：**从客户端看，一致性主要指多并发访问时更新后的数据如何获取的问题。

**服务端：**从服务端看，则是更新后的数据如果分布到整个系统，以保证数据最终一致。

一致性的程度不同，大致分为强一致性、弱一致性和最终一致性三大类。

- **强一致性：**对于关系型数据库，要求更新过的数据能被后续的访问看到。
- **弱一致性：**能容忍后续的部分或全部访问不到。
- **最终一致性:**如果经过一段时间后要求能访问到更新后的数据。

## Availability可用性

可用性指服务一直可用，而且是正常响应时间。不管什么时候访问，都可以正常的获取数据值。

## Partition tolerance 分区容错性

分区容错性指遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

## CAP特性取舍

- 满足CA舍弃P：也就是满足一致性和可用性，舍弃分区容错性。就意味着系统不是分布式的了，因为涉及分布式的想法就是把功能分开，部署到不同机器上。
- 满足CP舍弃A：满足一致性和分区容错性，舍弃可用性。如果允许系统有段时间的访问失效等问题，这个是可以满足的。例如并发买票，后台网络出现故障，买的时候系统崩溃。
- 满足AP舍弃C：满足可用性和分区容错性，舍弃一致性。意味着你的系统在并发访问的时候会出现数据不一致的情况。

事实证明，大多数是实现了一致性，向12306、淘宝，看到还有一张票，但是买的时候已经没有了。



项目中因为对数据不要求实时性，只要能够满足最终一致性即可，但必须保证服务的可用性，所以时牺牲掉了一致性，即满足AP舍弃C



# MySql有哪些索引





# MySQL是否解决幻读，如何解决幻读?



MySQL默认的事务处理级别是可重复读，提供的四种隔离级别：

- 未提交读（Read Uncomitted）：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。
- 提交读（Read Committed）：解决了脏读，存在幻读，只读取已经提交的数据。（幻读：在一次事务中，多次查询之后，结果集的个数不一致的情况叫做幻读）
- 可重复读（Repeated Read）：在同一事务内的查询都是事务开始时刻一致的。解决了脏读和幻读
- 串行读（Serializable）：完全串行化读，每次读都要获得表级共享锁，读写相互都会阻塞。





# 项目中对高可用做了哪些东西



对系统进行集群部署，内部采用负载均衡、实时监控、优化配置；外部增加硬件配置



# 集群中的服务挂掉了怎么处理





# 线程池的拒绝策略





# Redis内存淘汰策略

## Redis过期策略

### 定期刪除：

redis会将每个设置了过期时间的key放到一个独立的字典中，以后会定期遍历这个字典来删除到期的key。

Redis默认会每秒进行十次过期扫描（100ms一次），过期扫描不会遍历过期字典里面的所有key，而是采用一种简单的贪心策略。

1. 从过期字典中随机20个key；
2. 删除这20个key中已经过期的key；
3. 如果过期的key比率超过1/4，就重复步骤1.

采用随机抽取，减少CPU的负载，如果redis存储了几十万个key，每隔100ms就遍历所有设置过期时间的key，会给CPU带来很大的负载。

### 惰性删除：

就是客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除，不会返回任何东西。

总结：定期删除是集中处理；惰性删除是零散处理。



## 为什么需要淘汰策略

因为不管是定期删除还是惰性删除都不是一种完全精准的删除，还是会存在key没有被删除的场景。所以内存淘汰策略进行补充。

### 内存淘汰策略

配置文件中使用maxmemory-policy 设置内存淘汰策略；maxmemery最大内存

- noeviction：默认策略，当内存使用达到设置的最大值时，所有申请内存的操作（如set，lpush等）都会报错，只读操作如get命令可以正常执行，不会驱逐任何键。
- volatile-lru：从设置了过期时间的key中删除**最久没有使用**的键。
- allkeys-lru：通过LRU算法删除**最久没有使用**的键值。
- volatile-lfu：从设置了过期时间的key中删除马上要过期的键。
- allkeys-lfu：从所有key中删除使用频率最少的键值。
- volatile-random：从设置了过期key的集合中随机删除。
- allkeys-random：从所有key中随机删除。
- volatile-ttl：从设置了过期时间的key中删除马上快要过期的键。

## LRU（Least Recently Used）算法

表示最近最少使用，该算法根据数据的历史访问记录来淘汰数据，其核心思想就是“如果数据最近被访问过，那么将来被访问的几率也更高”

### 标准LRU实现方式

1. 新增key value的时候首先在链表结尾添加Node节点，如果超过LRU设置的阈值就淘汰队头的节点并删除掉HashMap中对应的节点。

2. 修改key对应的值的时候先修改对应的Node中的值，然后把Node节点移动队尾。

3. 访问key对应的值的时候把访问的Node节点移动到队尾即可

### **Redis的LRU实现**

Redis维护了一个24位时钟，可以简单理解为当前系统的时间戳，每隔一定时间会更新这个时钟。每个key对象内部同样维护了一个24位的时钟，当新增key对象的时候会把系统的时钟赋值到这个内部对象时钟。比如我现在要进行LRU，那么首先拿到当前的全局时钟，然后再找到内部时钟与全局时钟距离时间最久的（差最大）进行淘汰，这里值得注意的是全局时钟只有24位，按秒为单位来表示才能存储194天，所以可能会出现key的时钟大于全局时钟的情况，如果这种情况出现那么就两个相加而不是相减来求最久的key。

Redis中的LRU与常规的LRU实现并不相同，常规LRU会准确的淘汰掉队头的元素，但是Redis的LRU并不维护队列，只是根据配置的策略要么从所有的key中随机选择N个（N可以配置）要么从所有的设置了过期时间的key中选出N个键，然后再从这N个键中选出最久没有使用的一个key进行淘汰。



# Config中心配置的原理

三台集器，如果要改一个配置，配置信息一致性原理是怎样的？





# Ribbon负载均衡怎么做的

默认是用什么策略

随机、轮询、哈希一致性

# Hystrix服务熔断使用方法级别还是接口级别







# Spring循环依赖问题





# 如何设计幂等性

- 方法一：令牌Token机制（全局ID）（记录并检查操作）

  客户端在调用接口的时候先向后端请求一个全局ID（Token），请求的时候携带这个token一起请求，后端对这个全局ID校验来保证幂等操作。

  服务器端派发token并将token记录在缓存汇中，客户端携带该token请求服务，如果次token有效，处理请求，并删除token，token无效忽略此次请求。

- 方法二：数据库去重表

  在往数据库中插入数据的时候，利用数据库唯一索引特性，保证数据唯一，也可以是多个字段的组合，保证唯一性。

- 方法三：状态机制

  添加业务状态，比如库存单据状态已审核、待出库、出库中、已归档等，后端通过不同状态保证幂等性，比如扫描出库的时候，单据状态必须是待出库状态

# SpringBoot的常用注解



@ComponentScan：

@EnableAutoConfiguration：

# Kafka



kafka如果解决消费失败问题





# 线程池参数

ThreadPollExecutor：corePollSize、

# 算法

1. 找出字符串中重复子串的长度

   解决思路：滑动窗口

   

https://juejin.cn/post/6844904120634064903

