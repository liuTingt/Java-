# 一、程序如何运行又是如何崩溃的

## 1、程序如何运行

可执行的代码被成为程序，程序运行起来被称作进程。程序运行如果需要创建数组等数据结果，操作系统会在进程的堆空间申请一块内存空间，把内存首地址信息记录在进程的栈中。

堆是一块无序的内存空间。

栈是一个先进后出的数据结构。每次函数调用都会在栈中创建栈帧（stack frame），存储正在执行函数的参数、局部变量、申请的内存地址等。

![程序如何运行的](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\程序如何运行的.png)

## 2、JDK8之后的JVM内存布局

![图摘自《码出高效》](https://upload-images.jianshu.io/upload_images/14923529-c0cbbccaa6858ca1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 程序计数器

Program Count Register是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每条线程有一个独立的程序计数器，是线程私有的内存。

如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器则为空。

### Java虚拟机栈

Java虚拟机栈也是线程私有的，它的生命周期与线程相同。

虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，对应着栈帧从虚拟机栈入栈和出栈的过程。

![操作栈的压栈与出栈-《码出高效》](https://upload-images.jianshu.io/upload_images/14923529-7a6d6e02c15fff2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



1

2

3

### 本地方法栈



### Java堆

Java堆是Java虚拟机所管理的最大的内存最大的一块。Java堆是被所有线程共享的一块内存区域，用于存放对象实例。

### 方法区







## 3、进程状态



## 4、系统为什么会变慢，为什么会崩溃

现在的服务器软件系统主要使用多线程实现多任务处理。为了解决线程安全问题，使用锁机制，将临界区的代码加锁。锁会引起线程阻塞，如果多线程运行，那么就会出现线程阻塞的情况，线程无法并行执行，系统响应速度就会变慢。此外，I/O操作也会引起阻塞，对数据库连接的获取也会阻塞，如果并发数超过了数据库的连接数，那么就会有部分线程无法获取连接而阻塞，并发的线程越多，等待连接的时间也越多，响应时间就会边长，**系统变慢**。

被阻塞的线程越多，占据的资源也越多，被阻塞的线程即不能执行，也不能释放当前占用的资源，在系统中一边等待一边消耗资源，如果阻塞的线程超过了系统某个系统资源的极限，就会导致系统宕机，**应用崩溃**。

解决高并发导致的系统变慢、应用崩溃主要手段是使用分布式系统架构。

## 名词解释：

**栈帧：**每次函数调用，操作系统会在栈中创建一个栈帧，保存当前执行函数的参数、局部变量、申请内存地址等，栈帧是隔离的，所以不同函数可以定义相同的变量而混淆。

**临界区：**多个线程共享资源的这段代码被称为临界区。

参考资料：https://www.cnblogs.com/czwbig/p/11127124.html

## 二、Hash表的时间复杂度为什么是O(1)

### 数组

是一种线性表，即只有一个前驱数据元素和一个后继数据元素。

创建数组必须要内存中一块连续的空间，并且存放相同类型的数据结构。

查找的时间复杂度为O(1)，增加删除的时间复杂度为O(N)。

### 链表

是一种线性表，可以使用零散的内存空间存储数据。

查找的时间复杂度为O(N)，增加删除的时间复杂度为O(1)。

### Hash表

是一种线性表，以key、value的方式存储。Hash表底层采用数组和链表的形式存储。

Hash表在不存在hash冲突的情况下，物理存储是一个数组，查询的时间复杂度为O(1)；如果存在hash冲突，Hash表退化为一条链表，查询的时间复杂度为O(N)。

### 栈

栈是一种线性表，是一种先进后出（FILO）的数据结构。

在程序运行过程中，方法的调用需要用栈来管理每个方法的工作区，不管如何嵌套调用，栈顶元素始终是当前正在执行的方法的工作区。

### 队列

队列是一种先进先出（FIFO）的数据结构。

### 树

树是非线性表。

# 三、Java虚拟机原理

## JVM的组成构造

JVM主要有类加载器、运行时数据区、执行引擎三部分组成。

![JVM构成](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\JVM构成.png)

运行时数据区包括方法区、堆、Java栈、程序计数寄存器。

方法区主要存放从磁盘加载进来的类字节码。

堆主要存放程序运行过程中创建的对象实例信息（对象实例信息主要是成员变量），方法内创建的对象实例信息也存放到堆中，对象的引用存放在栈中。

Java栈主要存放运行期的局部变量、对象实例的内存地址引用。

程序计数寄存器存放当前线程执行到哪一行字节码指令。

## Java程序执行过程

通过Java命令启动JVM，JVM加载.class类文件到方法区内。JVM创建主线程执行这个类文件的main方法，main方法的输入参数和方法内定义的变量被压入Java栈中。如果在方法内创建了对象实例，这个对象实例信息被存放到堆中，而对象实例的引用，即对象实例在堆中的地址信息被存放到栈中。堆中记录的对象实例主要是成员变量信息，因为类中方法的可执行代码在方法区中，方法内的局部变量在线程的栈中。

程序计数寄存器刚开始记录main方法的第一行代码位置，JVM执行引擎根据该位置到方法区加载这行代码指令，将它解释为自身所在平台的CPU指令后交给CPU执行。当main方法中调用其他方法的时候，会在线程栈中创建新的栈帧，存放调用方法的局部变量和输入参数，执行完调用方法后，栈帧出栈，这样当前栈帧又回到main方法的栈帧。栈帧之间是隔离的。

## Java的线程安全

线程中的栈帧是隔离的，虽然所有方法内创建的对象实例在堆中，但是对象引用在栈帧中，栈帧又是隔离的，因此是线程安全的。

像Servlet这样的类，在Web容器中创建后，会被传递给每个访问Web容器的用户线程执行，这个类就不是线程安全的。但这不意味着会存在线程安全问题，如果Servlet类中没有成员变量，即使多个线程同时执行这个Servlet实例的方法，也不会造成成员变量冲突。这种对象被称为无状态对象，也就是说对象不记录状态，执行这个对象的任何方法都不会改变对象的状态，也就不会有线程安全问题了。在Web开发实践中，Service类、DAO类都被设计为无状态对象。

## JVM的垃圾回收

JVM如何知道哪些对象不再被使用 ，可以清理掉的呢？
JVM通过一种可达性分析算法进行垃圾对象的识别。具体过程是：从线程栈帧中的局部变量，或者方法区的静态变量出发，将这些变量引用的对象进行标记，然后看这边被标记的变量是否引用了其它对象，继续标记，所有被标记的对象都是被使用的对象，未标记的对象就是可以回收的垃圾对象了，所以可达性分析算法是一种引用标记算法。

标记后，JVM会对垃圾对象占用的内存进行回收，回收主要有三种方法：

1. 第一种方式是清理：将垃圾对象占用的内存清理掉。JVM并不会真的将这些垃圾内存进行清理，而是将他们标记为空闲，记录在一个空闲列表里，当应用程序需要创建新对象时，就从空闲列表中找一段空闲内存分配给新对象。

   缺点：空闲内存不是连续的。当应用程序创建一个数组需要申请一块连续的大内存空间时，即使堆空间有足够的空闲空间，也无法未应用程序分配内存。

2. 第二种方式是压缩：从堆空间的头部开始，将存活的对象拷贝放在一段连续的内存空间中，那么其余空间就是连续的空闲空间。

3. 第三种方式是复制：将堆空间分为两部分，只在其中一部分创建对象，当这个部分的空间用完时，将标记过的对象复制到另一个空间中。JVM将这两部分空间分别命名为from区域和to区域。当对象从from区域复制到to区域后，两个区域交换名称引用，继续在form区域创建对象，知道form区域满。

下面的图可以直观了解JVM三种不同的垃圾回收机制。

回收前：

![标记后的堆空间](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\标记后的堆空间.png)

清理：

![清理后的堆空间](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\清理后的堆空间.png)

压缩：

![压缩后的堆空间](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\压缩后的堆空间.png)

复制：

![复制后的堆空间](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\复制后的堆空间.png)

JVM将堆空间分为新生代（Young）和老年代（Old）两个区域，只在新生代创建对象，当新生代空间不足时，只对新生代进行垃圾回收，这样需要处理的内存空间比较小，垃圾回收的速度就比较快。

新生代又分为Eden区、From区和To区，每次垃圾回收先扫描Eden和From区，将存活对象复制到To区，交换From和To区的名称引用，下次垃圾回收时继续将存活的对象从Eden区和From区复制到To区。当一个对象经历过几次新生代垃圾回收后，依然存活，那么这个对象会被复制到老年代区。

当老年代空间已满，也就是无法将新生代中多次回收依然存活的对象复制进入的时候，就会对新生代和老年代进行一次全量垃圾回收，即Full GC。所以根据应用程序对象的存活时间，合理设置老年代和新生代的空间比例对JVM垃圾回收性能有很大影响，JVM设置老年代新生代比例的参数：-XX:NewRatio

![下载](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\下载.png)

JVM中，具体执行垃圾回收的垃圾回收器有四种：

1. Serial串行垃圾回收器：这是JVM早期的垃圾回收器，只有一个线程执行垃圾回收。

2. Parallel并行垃圾回收器：启动多个线程执行垃圾回收。

   串行和并行垃圾回收的过程中，必须要停止用户线程的工作，否则可能会导致对象的引用标记错乱，因此垃圾回收过程也被成为stop the world。

3. CMS并发垃圾回收器：在垃圾回收的某些阶段，垃圾回收线程和用户线程可以并发运行，因此对用户的影响较小。

4. G1垃圾回收器：它将整个堆空间分成多个子区域，然后在这些子区域上独立进行垃圾回收，回收过程中，垃圾回收线程和用户线程也是并发运行。G1综合了前几个垃圾回收器的优势，适用于各种场景，是未来主要的垃圾回收器。

# 四、网络编程原理

## DNS

域名解析服务器，将域名解析为具体的IP地址。

## CDN

事实上DNS解析出来的IP地址，不一定是淘宝数据中心的IP地址，也可能是淘宝CDN服务器的IP地址。

CDN是内容分发网络（Content Delivery Network）的缩写，是在运营服务商接入的机房中部署的一些缓存服务器。例如，为了提高用户请求访问的速度，也为了降低数据中心的负载压力，淘宝会在全国各地各个主要运营服务商的接入机房中部署一些服务器，缓存静态图片、资源、文件等，这些缓存服务器构成了淘宝的CDN。

![下载 (1)](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\下载 (1).png)

## TCP/IP协议

![协议](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\协议.png)

### 物理层

服务数据的物理传输，计算机输入输出只能是0 1这样的二进制，但是在真正的通信线路里有光纤、电缆、无线各种设备，不同设备的信号在物理上是不同的，如何让这些不同的设备能够理解、处理二进制数据，这是物理层要解决的问题。

### 数据链路层

就是将数据进行封装后交给物理层进行传输，主要讲数据封装未数据帧，以帧为单位通过物理层进行通信，有了帧，可以在帧上进行数据校验，进行流量控制。数据链路层会定义帧的大小，这个大小被成为最大传输单元。

数据链路层会在帧里添加一个帧头，帧头里记录着发送者和接收者的mac地址。

### 网络层协议IP

网络层的数据需要交给数据链路层进行处理，网络层的IP数据包必须要小于最大传输单元才能进行网络传输，这个数据包也有一个IP头，主要包括发送者和接收者的IP地址。

### 传输层协议TCP

要保证通信的稳定可靠，需要传输层协议TCP。TCP协议在传输正式数据前，会先建立连接，这就是著名的TCP三次握手。

![tcp三次握手](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\tcp三次握手.png)

报文中SYN表示请求建立连接，ACK表示确认。

1.APP发送SYN=1 Seq=X的报文，表示请求连接
2.服务器收到报文后，应答报文，表示同意建立连接
3.APP接收报文后，检查ACK值为自己发送的Seq值+1，确认建立连接，并发送ACK=Y+1报文给服务器
4.服务器接收报文后，检查ACK为自己发送的Seq值+1，确认连接
至此APP和服务器建立起TCP通信，可以进行数据传输了。

TCP也会在数据包上添加TCP头，TCP头除了包含一些用于校验数据正确性和控制数据流量的信息外，还包含通信端口信息

### 应用层协议HTP

是一个应用层协议

响应码：

3XX：重定向

4XX：客户端错误，403表示请求未授权，404表示请求不存在

5XX：可是服务器异常，502表示请求处理超时，503服务器过载。



以POST方法提交一个搜索请求给淘宝服务器，最终在数据链路层构建出来的数据帧大概如下：

![数据帧](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\数据帧.png)

### LB（负载均衡）

负载均衡的实现手段有很多层种，淘宝这样规模的应用，通常使用Linux内核支持的链路层负载均衡。

![负载均衡](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\负载均衡.png)

# 五、文件系统原理

分布式文件系统HDFS

# 六、数据库原理

## 1、数据库架构与SQL执行过程

一条SQL提交到数据库，经过连接器将SQL语句交给语法分析器，生成一个**抽象语法树AST**；AST经过语义分析与优化器，进行语义优化，使计算过程和需要获取的中间数据尽可能少，然后得到数据库的**执行计划**；执行计划交给具体的执行引擎进行计算，将结果通过连接器再返回给应用程序。

SQL-->连接器-->语法分析器-->语义分析与优化器-->执行引擎

## 2、使用PrepareStatement执行SQL的好处

第一：PrepareStatement会预先提交占位符的SQL到数据库进行预处理，提前生成执行计划，当给定占位符参数，真正执行SQL的时候，执行引擎可以直接执行，效率更好一点。

第二：可以防止SQL注入攻击。

加入根据用户名称查询用户功能，页面输入名称，SQL如下：

```
正常输入名称Carol：
select * from user where name ='Carol';
非正常输入Carol';drop table users;--：
select * from user where name = 'Carol';drop table users;--
SQL提交后会被当成两条语句执行
```

使用PrepareStatement，在一开始就已经提交了查询SQL，并被数据库预先生成好的执行计划，后面不管黑客提交什么样的字符串，都只能交给这个执行计划去执行，不可能再生成一条新的SQL语句。

```
select * from user where name = ?
```

## 3、数据库文件存储原理

**为什么索引能加快查询速度？**

数据库索引存储使用B+树。B+树是一种N叉排序树，树的每个节点包含N个数据，这些数据按顺序排好，两个数据之间是一个指向子节点的指针，而子节点的数据在这两个数据大小之间。

![B+树](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\B+树.png)

B+树存储在磁盘上，每个节点存储1000多个数据，树的深度只要四层就能存储数亿的数据。如果将树的根节点缓存在内存中，则最多只需要三次磁盘访问就能倒找索引。

**B+树加快了检索索引的速度，如何通过索引加快查询数据库记录的查询速度呢？**

数据库索引有两种，第一种**聚簇索引**，聚簇索引的数据库记录和索引存储在一起，上面就是聚簇索引的示意，索引1 和记录行r1存储在一起。MySQL数据库的主键就是聚簇索引，主键ID和所在行记录存储在一起。

另一种数据库索引是**非聚簇索引**，非聚簇索引在叶子节点记录的不是数据库行记录，而是聚簇索引，也就是主键。如下图：

![非聚簇索引](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\非聚簇索引.png)

通过B+树在叶子节点找到非聚簇索引a，和索引a在一起的是主键1，再根据主键1，通过主键（聚簇）索引找到对应的记录，这种通过非聚簇索引找到主键索引，再通过主键索引找到行记录的过程也成为回表。

所以通过索引，可以快速查询到需要的记录，如果要查询的字段上没有索引，就只能扫描整张表了，查询速度慢很多。

## 4、索引是否尽可能的多

索引要合理创建，索引占用物理空间，大量的索引耗费一定的空间；当对表中数据进行增删改的时候，如果有索引，那么索引也要动态的修改，会降低SQL执行效率。

# 七、编程语言原理

# 八、软件建模

4+1视图即逻辑视图、开发视图、过程视图、物理视图、场景视图、

# 九、软件设计

开发分为需求分析、概要设计、详细设计阶段。

## 常见UML图：

- 类图：描述类的特性和类之间的静态关系。类之间静态关系有关联、依赖、组合、聚合、继承、泛化。类图主要在**详细设计阶段、需求分析阶段**画
- 序列图：描述参与者之间的动态调用关系。在软件设计的不同阶段都可以画序列图
- 组件图：描述组件之间的静态关系，主要是依赖关系，一般用在**概要设计阶段**。
- 部署图：描述软件系统的最终部署情况。主要用在**概要设计阶段**。
- 用例图：通过反映用户和软件系统的交互，描述系统的功能需求。主要用在**需求分析阶段**。
- 状态图：用来展示单个对象生命周期的状态变迁。要在**需求分析阶段**画，描述状态变迁的逻辑关系，在**详细设计阶段**也要画，用枚举值表示，指导开发。
- 活动图：描述过程逻辑和业务流程。可以在**需求分析阶**段描述业务流程，也可以在**概要设计阶段**描述子系统和组件的交互，还可以在**详细设计阶段**描述一个类方法内部的计算流程。

# 十、软件设计的目的

## 1、开闭原则

扩展开放，修改关闭。

可用如下模式实现：

- 策略模式：

  策略模式是一种行为模式，多个策略实现同一个策略接口

- 适配器模式：

  是一种结构模式，用于将两个不匹配的接口适配起来

- 观察者模式：

  观察者模式是一种行为模式，解决一对多的对象依赖关系，将被观察者的行为通知到多个观察者。

- 模板方法模式：就是在父类中，用抽象方法定义计算的骨架和过程，而抽象方法的实现则留在子类中。

## 2、依赖倒置原则

依赖倒置原则是这样的：
高层模块不应该依赖底层模块，二者应该抽象依赖；
抽象不应该依赖具体实现，具体实现应该依赖抽象。

框架的实现使用了依赖倒置原则，比如Tomcat、Spring、MyBatis框架，我们并没有调用框架的代码，但是可以使用框架的功能特性，是因为我们实现了框架的接口，被框架调用。

依赖倒置原则中抽象接口应是高层的抽象接口，像日常开发的service层调用dao层的接口，并不是依赖倒置原则。应该在service层定义一个抽象层，让dao层去实现。

依赖倒置原则的编码守则：

1. 应用代码中多使用抽象接口，尽量避免使用哪些多变的具体实现类；
2. 不要继承具体类，如果一个类在设计之初不是抽象类，那么尽量不要去继承它。对具体类的继承是一种强依赖关系，维护的时候难以改变；
3. 不要重写包含具体实现的函数。

## 3、里氏替换原则

有一个关于继承的替换原则，叫做里氏替换原则。这个原则说，若每个类型T1的对象o1，都存在一个类型T2的对象o2，使得在所有针对T2变成的程序P中，用o1替换o2后，程序P的行为功能不变，则T1是T2的子类。

通俗的讲子类必须能够替换掉他们的基类。

一个违反里氏替换规则的例子

```
void drawShape(Shape shape) {
	if(shape.type == Shape.Circle) {
		drawCircle((Circle)shape);
	} else if (shape.type == Shape.Square) {
		drawCircle((Shape)shape);
	}else {
		....
	}
}
```

if/else违反了开闭原则，同时也违反了里氏替换原则，当新增Shape类型的时候，必须要修改该方法，否则这个新类型就无法替换积累Shape

解决这个问题可以，在基类Shape中定义draw方法，所有的子类Circle、Shape都可以实现这个方法既可以了。

通常判断一个继承是否合理，会使用 “is a ”判断，类B继承类A，我们就说类B is a 类A。

通常子类比父类的契约更严格，都是违反里氏替换原则。子类不能比父类更小的访问权限，如果父类访问控制符为protected，那么子类在重写这个方法时，可以改成public，但是不能改为private。子类抛出的异常要是父类的抛出异常的子类，如果父类抛出classNotFindException，子类抛出的异常要是classNotFindException子类或是classNotFindException。

通常说组合由于继承。

## 4、单一职责原则



## 5、接口隔离原则（ISP）

如何对类的调用者隐藏公有方法？

接口隔离原则：客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。

接口隔离原则，可以将一个实现类的不同方法包装在不同的接口中对外暴露。

代码示例：

![img](https://bkimg.cdn.bcebos.com/pic/5882b2b7d0a20cf4128485a176094b36acaf99b3?x-bce-process=image/resize,m_lfit,w_220,h_220,limit_1/format,f_auto)

```
interface IorderForProtal{
	String getOrder();
}
interface IOrderForOtherSys{
	String insertOrder();
	String getOrder();
}
interface IOrderForAdmin{
	String deleteOrder();
	String updateOrder();
	String insertOrder();
	String gerOrder();
}
class Order implements IOrderForPortal,IOrderForOtherSys,IOrderForAdmin{
    private Order(){
        //--什么都不干,就是为了不让直接 new,防止客户端直接New,然后访问它不需要的方法.
    }
    //返回给Portal
    public static IOrderForPortal getOrderForPortal(){
        return (IOrderForPortal)new Order();
    }
    //返回给OtherSys
    public static IOrderForOtherSys getOrderForOtherSys(){
        return (IOrderForOtherSys)new Order();
    }
    //返回给Admin
    public static IOrderForAdmin getOrderForAdmin(){
        return (IOrderForAdmin)new Order();
    }
    //--下面是接口方法的实现.只是返回了一个String用于演示
    public String getOrder(){
        return "implemented getOrder";
    }
    public String insertOrder(){
        return "implemented insertOrder";
    }
    public String updateOrder(){
        return "implemented updateOrder";
    }
    public String deleteOrder(){
        return "implemented deleteOrder";
    }
}
public class TestCreateLimit{
    public static void main(String[] args){
        IOrderForPortal orderForPortal =Order.getOrderForPortal();
        IOrderForOtherSys orderForOtherSys =Order.getOrderForOtherSys();
        IOrderForAdmin orderForAdmin = Order.getOrderForAdmin();
        System.out.println("Portal门户调用方法:"+orderForPortal.getOrder());
        System.out.println("OtherSys外部系统调用方法:"+orderForOtherSys.insertOrder());
        System.out.println("Admin管理后台调用方法:"+orderForAdmin.getOrder()+";"+orderForAdmin.insertOrder()+";"+orderForAdmin.updateOrder()+";"+orderForAdmin.deleteOrder());
    }
}
```

模式是可重复的解决方案。设计模式的精髓是多态的灵活应用。

Tomcat等web容器使用了策略模式和模板方法模式实现。策略接口就是Servlet接口，我们开发的代码就是实现Servlet接口。HttpServlet用到了模板方法模式，所谓模板方法模式，就是在父类中用抽象定义计算的骨架和过程，而抽象方法的实现则留在子类中。

框架是对某一类架构方案可复用的设计与实现。

# 十八、反应式编程框架

Flower反应式编程框架，提供异步调用服务，通过流程编排的方式进行服务调用，而不是通过接口依赖的方式进行调用。Flower框架底层基于akka做异步调用的。

# 十九、领域驱动设计

领域驱动设计DDD

# 二十二、缓存架构

缓存可以分为两种，通读缓存和旁路缓存：

**通读缓存：**应用程序访问通读缓存获取数据的时候，如果通读缓存中有应用程序需要的数据，则返回这个数据，如果没有，那么通读缓存就自己负责访问数据源，从数据源获取数据返回给应用程序，并将数据缓存在自己的缓存中。

**旁路缓存：**应用程序访问旁路缓存获取数据的时候，如果旁路缓存中存在应用程序需要的数据，则返回这个数据，如果没有，则返回null，应用程序需要自己访问数据源获取数据，然后将这个数据写入旁路缓存中。

## 通读缓存

互联网应用中主要使用的通读缓存是CDN和反向代理。

### CDN（Content Delivery Network）

即内容分发网络，部署在网络服务商机房中的缓存就是CDN，CDN只能缓存静态数据内容，比如图片、CSS、JS等。而动态内容必须要应用服务器进行计算处理后才能获得。

### 反向代理缓存

我们上网的时候，有时需要代理上网，这个代理代理的是我们客户端的上网设备。而反向代理则代理服务器，是应用程序服务器的门户，所有网络请求都需要通过反向代理才能够到达应用程序服务器。既然所有的请求都需要通过反向代理，那在这里加一个缓存，尽快将数据返回给用户，而不是发送给应用服务器，这就是反向代理。

![反向代理服务器](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\反向代理服务器.png)

## 旁路缓存

应用程序在代码中主要使用的是对象缓存，对象缓存是一种旁路缓存。

## 缓存注意事项

### 优点

1. 缓存数据通常存储在内存中，因此响应时间更快，性能表现更好；
2. 使用缓存可以减少CPU的计算消耗，节省计算资源，同样加快处理速度；
3. 通过缓存获取数据，可以减少数据库的负载压力。

### 带来问题

首先是数据脏读的问题，缓存的数据来自数据源，如果数据源中的数据被修改了，那么缓存中的数据就变成了脏数据。

主要解决办法有两个：一个是**过期失效**，每次写入缓存中的数据都标记其失效时间，在读取缓存的时候，检查是否已经失效过期。另一个办法是**失效通知**，应用程序修改数据源的数据，同时发送通知，将该数据从缓存中清除。在实践中，更多使用的还是过期失效。

如果缓存的数据没有热点，写入缓存中的数据很难被重复读取，那么使用缓存就不是很有必要了。

使用Hash求余算法进行路由，如果缓存服务器集群扩容，会造成相同的值被路由到不同的服务器上，导致大量缓存失效，针对这个问题可以采用**一致性哈希算法**

# 二十三、异步架构

使用消息队列实现异步架构，优点：

1. 改善写操作请求的响应时间

   生产者应用程序发送消息到消息队列后，就可以继续向下执行了，无序等待耗时的消息消费处理。

2. 更容易进行伸缩

   可以单独对消费者服务器进行伸缩，而无序对整个应用程序集群进行伸缩。

3. 削峰填谷

   利用消息队列，可以将需要消费的消息放入消息队列，而消费者可以控制消费的速度，因此能够降低系统访问高峰时压力，而在低估时还可以继续处理消息队列中的消息。

4. 隔离失败

   使用消息队列，生产者发送消息后就继续自己下面的程序，消费者如果在处理消息的过程中失败，不会传递给生产者，应用程序具有更高的可用性。

5. 降低耦合

   可以降低调用者和被调用者的耦合，同时调用者发送消息到消息队列，不需要依赖被调用者的代码和处理结果，增加新的功能，只需要增加新的消费者就可以了。

对于需要被调用者返回结果的事件，可以给用户状态提醒，等消费者程序处理完后，发送消息给用户。

# 二十四、负载均衡架构

## HTTP重定向负载均衡

来自用户的请求到达负载均衡服务器后，负载均衡服务器根据某种负载均衡算法计算得到一个应用服务器IP地址，负载均衡服务器将IP地址返回给用户，用户浏览器收到重定向响应以后，从新发送请求到真正的应用服务器，以此实现负载均衡。

![HTTP负载均衡](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\HTTP负载均衡.png)

优点：设计简单

缺点：用户完成一次访问需要请求两次数据中心，一次请求负载均衡服务器，一次请求应用服务器，请求处理性能会受很大影响。
另一个问题是响应要重定向到真正的服务器，所以需要把应用服务器IP地址暴露给外部用户，这样会带来安全问题。

## DNS负载均衡

域名转换为IP就是DNS服务器完成，这时候就可以在DNS域名解析的时候进行负载均衡，也就是不同用户在进行域名解析的时候，返回不同的应用服务器IP地址，从而实现负载均衡。

![DNS负载均衡](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\DNS负载均衡.png)

与HTTP重定向不同，用户每次请求进行DNS域名解析，第一次解析后，域名缓存在本机，后面很长时间都不会进行域名解析，因此性能方面不会是问题。

如图，域名解析直接得到应用服务器IP地址，确实会存在安全问题。但是大型互联网应用通常不直接通过DNS解析得到应用服务器IP地址，而是解析得到负载均衡服务器IP地址，然后通过负载均衡服务器将用户请求分发到不同的应用服务器上，即经过了两次负载均衡。通过这种方式，应用服务器不需要用公网IP将自己暴露给外部访问者，避免了安全性问题。

## 反向代理服务器

在缓存架构中体到用户请求到达数据中心，首先到达的就是反向代理服务器。反向代理服务器查找本机是否有请求的资源，如果有直接返回资源数据，如果没有就将请求发送给应用服务器继续处理。事实上在发送给应用服务器的时候，就可以进行负载均衡，将不同用户的请求发送到不同服务器上。Nginx这样的HTTP服务器就会同时提供反向代理与负载均衡功能。

![反向代理服务器负载均衡](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\反向代理服务器负载均衡.png)

反向代理服务器是工作在HTTP协议层之上的，所以它代理的也是HTTP的请求和响应。作为互联网应用层的一个协议，HTTP协议相对来说比较重，效率比较低，所以反向代理通常在小规模的互联网系统上。

## IP负载均衡

反向代理是工作在应用层网络协议上的负载均衡，因此也叫做应用负载均衡。应用层之下的负载均衡方法是在TCP/IP协议的IP层进行负载均衡。工作原理是，用户请求到达负载均衡服务器后，负载均衡服务器会对网络层的数据包的IP地址进行转换，，修改IP地址，将其修改为应用服务器的IP地址，然后把数据包重新发送出去，请求数据就会到达应用服务器。

![IP负载均衡](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\IP负载均衡.png)

IP负载均衡在操作系统内核直接修改IP数据包，因此，效率比反向代理负载均衡高得多。但是，不管是请求还是响应的数据包，都需要经过负载均衡服务器进行IP转换，才能够正确的把数据分发到应用服务器，或者正确的把数据包发送到用户端程序，请求的数据一般比较小，但是响应的数据不管是HTML、JS、CSS这样的资源，文件通常都会比较大，因此负载均衡服务器会是响应数据的流量瓶颈。

## 数据链路层负载均衡

数据链库层负载均衡可以解决响应数据量大而导致负载均衡服务器输出带宽不足的问题。数据链路层负载均衡服务器不会修改数据包的IP地址，而是修改数据链路层里的网卡mac地址。应用服务器和负载均衡服务器都是使用相同的虚拟机IP地址，这样IP路由就不会受到影响，但是网卡会根据自己的mac地址，选择负载均衡服务器发送到自己网卡的数据包，交给对应的应用程序去处理。当把响应的数据包发送到网络上时，因为IP地址没有修改过，所以这个响应会直接到达用户的浏览器，而不会再经过负载均衡服务器。

![数据链路层负载均衡](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\数据链路层负载均衡.png)

链路层负载均衡服务器避免响应数据再经过负载均衡服务器，因此可以承受较大的数据传输压力，所以，目前大型互联网应用基本使用链路层负载均衡。

Linux上实现Ip负载均衡和链路层负载均衡技术是LVS，目前LVS功能已经集成到Linux中了，通过Linux可以直接配置实现这两种负载均衡。