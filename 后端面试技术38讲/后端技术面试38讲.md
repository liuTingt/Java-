# 一、程序如何运行又是如何崩溃的

## 1、程序如何运行

可执行的代码被成为程序，程序运行起来被称作进程。程序运行如果需要创建数组等数据结果，操作系统会在进程的堆空间申请一块内存空间，把内存首地址信息记录在进程的栈中。

堆是一块无序的内存空间。

栈是一个先进后出的数据结构。每次函数调用都会在栈中创建栈帧（stack frame），存储正在执行函数的参数、局部变量、申请的内存地址等。

![程序如何运行的](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\程序如何运行的.png)

## 2、JDK8之后的JVM内存布局

![图摘自《码出高效》](https://upload-images.jianshu.io/upload_images/14923529-c0cbbccaa6858ca1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 程序计数器

Program Count Register是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每条线程有一个独立的程序计数器，是线程私有的内存。

如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器则为空。

### Java虚拟机栈

Java虚拟机栈也是线程私有的，它的生命周期与线程相同。

虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，对应着栈帧从虚拟机栈入栈和出栈的过程。

![操作栈的压栈与出栈-《码出高效》](https://upload-images.jianshu.io/upload_images/14923529-7a6d6e02c15fff2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



1

2

3

### 本地方法栈



### Java堆

Java堆是Java虚拟机所管理的最大的内存最大的一块。Java堆是被所有线程共享的一块内存区域，用于存放对象实例。

### 方法区







## 3、进程状态



## 4、系统为什么会变慢，为什么会崩溃

现在的服务器软件系统主要使用多线程实现多任务处理。为了解决线程安全问题，使用锁机制，将临界区的代码加锁。锁会引起线程阻塞，如果多线程运行，那么就会出现线程阻塞的情况，线程无法并行执行，系统响应速度就会变慢。此外，I/O操作也会引起阻塞，对数据库连接的获取也会阻塞，如果并发数超过了数据库的连接数，那么就会有部分线程无法获取连接而阻塞，并发的线程越多，等待连接的时间也越多，响应时间就会边长，**系统变慢**。

被阻塞的线程越多，占据的资源也越多，被阻塞的线程即不能执行，也不能释放当前占用的资源，在系统中一边等待一边消耗资源，如果阻塞的线程超过了系统某个系统资源的极限，就会导致系统宕机，**应用崩溃**。

解决高并发导致的系统变慢、应用崩溃主要手段是使用分布式系统架构。

## 名词解释：

**栈帧：**每次函数调用，操作系统会在栈中创建一个栈帧，保存当前执行函数的参数、局部变量、申请内存地址等，栈帧是隔离的，所以不同函数可以定义相同的变量而混淆。

**临界区：**多个线程共享资源的这段代码被称为临界区。

参考资料：https://www.cnblogs.com/czwbig/p/11127124.html

## 二、Hash表的时间复杂度为什么是O(1)

### 数组

是一种线性表，即只有一个前驱数据元素和一个后继数据元素。

创建数组必须要内存中一块连续的空间，并且存放相同类型的数据结构。

查找的时间复杂度为O(1)，增加删除的时间复杂度为O(N)。

### 链表

是一种线性表，可以使用零散的内存空间存储数据。

查找的时间复杂度为O(N)，增加删除的时间复杂度为O(1)。

### Hash表

是一种线性表，以key、value的方式存储。Hash表底层采用数组和链表的形式存储。

Hash表在不存在hash冲突的情况下，物理存储是一个数组，查询的时间复杂度为O(1)；如果存在hash冲突，Hash表退化为一条链表，查询的时间复杂度为O(N)。

### 栈

栈是一种线性表，是一种先进后出（FILO）的数据结构。

在程序运行过程中，方法的调用需要用栈来管理每个方法的工作区，不管如何嵌套调用，栈顶元素始终是当前正在执行的方法的工作区。

### 队列

队列是一种先进先出（FIFO）的数据结构。

### 树

树是非线性表。

# 三、Java虚拟机原理

## JVM的组成构造

JVM主要有类加载器、运行时数据区、执行引擎三部分组成。

![JVM构成](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\JVM构成.png)

运行时数据区包括方法区、堆、Java栈、程序计数寄存器。

方法区主要存放从磁盘加载进来的类字节码。

堆主要存放程序运行过程中创建的对象实例信息（对象实例信息主要是成员变量），方法内创建的对象实例信息也存放到堆中，对象的引用存放在栈中。

Java栈主要存放运行期的局部变量、对象实例的内存地址引用。

程序计数寄存器存放当前线程执行到哪一行字节码指令。

## Java程序执行过程

通过Java命令启动JVM，JVM加载.class类文件到方法区内。JVM创建主线程执行这个类文件的main方法，main方法的输入参数和方法内定义的变量被压入Java栈中。如果在方法内创建了对象实例，这个对象实例信息被存放到堆中，而对象实例的引用，即对象实例在堆中的地址信息被存放到栈中。堆中记录的对象实例主要是成员变量信息，因为类中方法的可执行代码在方法区中，方法内的局部变量在线程的栈中。

程序计数寄存器刚开始记录main方法的第一行代码位置，JVM执行引擎根据该位置到方法区加载这行代码指令，将它解释为自身所在平台的CPU指令后交给CPU执行。当main方法中调用其他方法的时候，会在线程栈中创建新的栈帧，存放调用方法的局部变量和输入参数，执行完调用方法后，栈帧出栈，这样当前栈帧又回到main方法的栈帧。栈帧之间是隔离的。

## Java的线程安全

线程中的栈帧是隔离的，虽然所有方法内创建的对象实例在堆中，但是对象引用在栈帧中，栈帧又是隔离的，因此是线程安全的。

像Servlet这样的类，在Web容器中创建后，会被传递给每个访问Web容器的用户线程执行，这个类就不是线程安全的。但这不意味着会存在线程安全问题，如果Servlet类中没有成员变量，即使多个线程同时执行这个Servlet实例的方法，也不会造成成员变量冲突。这种对象被称为无状态对象，也就是说对象不记录状态，执行这个对象的任何方法都不会改变对象的状态，也就不会有线程安全问题了。在Web开发实践中，Service类、DAO类都被设计为无状态对象。

## JVM的垃圾回收

JVM如何知道哪些对象不再被使用 ，可以清理掉的呢？
JVM通过一种可达性分析算法进行垃圾对象的识别。具体过程是：从线程栈帧中的局部变量，或者方法区的静态变量出发，将这些变量引用的对象进行标记，然后看这边被标记的变量是否引用了其它对象，继续标记，所有被标记的对象都是被使用的对象，未标记的对象就是可以回收的垃圾对象了，所以可达性分析算法是一种引用标记算法。

标记后，JVM会对垃圾对象占用的内存进行回收，回收主要有三种方法：

1. 第一种方式是清理：将垃圾对象占用的内存清理掉。JVM并不会真的将这些垃圾内存进行清理，而是将他们标记为空闲，记录在一个空闲列表里，当应用程序需要创建新对象时，就从空闲列表中找一段空闲内存分配给新对象。

   缺点：空闲内存不是连续的。当应用程序创建一个数组需要申请一块连续的大内存空间时，即使堆空间有足够的空闲空间，也无法未应用程序分配内存。

2. 第二种方式是压缩：从堆空间的头部开始，将存活的对象拷贝放在一段连续的内存空间中，那么其余空间就是连续的空闲空间。

3. 第三种方式是复制：将堆空间分为两部分，只在其中一部分创建对象，当这个部分的空间用完时，将标记过的对象复制到另一个空间中。JVM将这两部分空间分别命名为from区域和to区域。当对象从from区域复制到to区域后，两个区域交换名称引用，继续在form区域创建对象，知道form区域满。

下面的图可以直观了解JVM三种不同的垃圾回收机制。

回收前：

![标记后的堆空间](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\标记后的堆空间.png)

清理：

![清理后的堆空间](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\清理后的堆空间.png)

压缩：

![压缩后的堆空间](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\压缩后的堆空间.png)

复制：

![复制后的堆空间](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\复制后的堆空间.png)

JVM将堆空间分为新生代（Young）和老年代（Old）两个区域，只在新生代创建对象，当新生代空间不足时，只对新生代进行垃圾回收，这样需要处理的内存空间比较小，垃圾回收的速度就比较快。

新生代又分为Eden区、From区和To区，每次垃圾回收先扫描Eden和From区，将存活对象复制到To区，交换From和To区的名称引用，下次垃圾回收时继续将存活的对象从Eden区和From区复制到To区。当一个对象经历过几次新生代垃圾回收后，依然存活，那么这个对象会被复制到老年代区。

当老年代空间已满，也就是无法将新生代中多次回收依然存活的对象复制进入的时候，就会对新生代和老年代进行一次全量垃圾回收，即Full GC。所以根据应用程序对象的存活时间，合理设置老年代和新生代的空间比例对JVM垃圾回收性能有很大影响，JVM设置老年代新生代比例的参数：-XX:NewRatio

![下载](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\下载.png)

JVM中，具体执行垃圾回收的垃圾回收器有四种：

1. Serial串行垃圾回收器：这是JVM早期的垃圾回收器，只有一个线程执行垃圾回收。

2. Parallel并行垃圾回收器：启动多个线程执行垃圾回收。

   串行和并行垃圾回收的过程中，必须要停止用户线程的工作，否则可能会导致对象的引用标记错乱，因此垃圾回收过程也被成为stop the world。

3. CMS并发垃圾回收器：在垃圾回收的某些阶段，垃圾回收线程和用户线程可以并发运行，因此对用户的影响较小。

4. G1垃圾回收器：它将整个堆空间分成多个子区域，然后在这些子区域上独立进行垃圾回收，回收过程中，垃圾回收线程和用户线程也是并发运行。G1综合了前几个垃圾回收器的优势，适用于各种场景，是未来主要的垃圾回收器。

# 四、网络编程原理

## DNS

域名解析服务器，将域名解析为具体的IP地址。

## CDN

事实上DNS解析出来的IP地址，不一定是淘宝数据中心的IP地址，也可能是淘宝CDN服务器的IP地址。

CDN是内容分发网络（Content Delivery Network）的缩写，是在运营服务商接入的机房中部署的一些缓存服务器。例如，为了提高用户请求访问的速度，也为了降低数据中心的负载压力，淘宝会在全国各地各个主要运营服务商的接入机房中部署一些服务器，缓存静态图片、资源、文件等，这些缓存服务器构成了淘宝的CDN。

![下载 (1)](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\下载 (1).png)

## TCP/IP协议

![协议](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\协议.png)

### 物理层

服务数据的物理传输，计算机输入输出只能是0 1这样的二进制，但是在真正的通信线路里有光纤、电缆、无线各种设备，不同设备的信号在物理上是不同的，如何让这些不同的设备能够理解、处理二进制数据，这是物理层要解决的问题。

### 数据链路层

就是将数据进行封装后交给物理层进行传输，主要讲数据封装未数据帧，以帧为单位通过物理层进行通信，有了帧，可以在帧上进行数据校验，进行流量控制。数据链路层会定义帧的大小，这个大小被成为最大传输单元。

数据链路层会在帧里添加一个帧头，帧头里记录着发送者和接收者的mac地址。

### 网络层协议IP

网络层的数据需要交给数据链路层进行处理，网络层的IP数据包必须要小于最大传输单元才能进行网络传输，这个数据包也有一个IP头，主要包括发送者和接收者的IP地址。

### 传输层协议TCP

要保证通信的稳定可靠，需要传输层协议TCP。TCP协议在传输正式数据前，会先建立连接，这就是著名的TCP三次握手。

![tcp三次握手](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\tcp三次握手.png)

报文中SYN表示请求建立连接，ACK表示确认。

1.APP发送SYN=1 Seq=X的报文，表示请求连接
2.服务器收到报文后，应答报文，表示同意建立连接
3.APP接收报文后，检查ACK值为自己发送的Seq值+1，确认建立连接，并发送ACK=Y+1报文给服务器
4.服务器接收报文后，检查ACK为自己发送的Seq值+1，确认连接
至此APP和服务器建立起TCP通信，可以进行数据传输了。

TCP也会在数据包上添加TCP头，TCP头除了包含一些用于校验数据正确性和控制数据流量的信息外，还包含通信端口信息

### 应用层协议HTP

是一个应用层协议

响应码：

3XX：重定向

4XX：客户端错误，403表示请求未授权，404表示请求不存在

5XX：可是服务器异常，502表示请求处理超时，503服务器过载。



以POST方法提交一个搜索请求给淘宝服务器，最终在数据链路层构建出来的数据帧大概如下：

![数据帧](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\数据帧.png)

### LB（负载均衡）

负载均衡的实现手段有很多层种，淘宝这样规模的应用，通常使用Linux内核支持的链路层负载均衡。

![负载均衡](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\负载均衡.png)

# 五、文件系统原理

分布式文件系统HDFS

# 六、数据库原理

## 1、数据库架构与SQL执行过程

一条SQL提交到数据库，经过连接器将SQL语句交给语法分析器，生成一个**抽象语法树AST**；AST经过语义分析与优化器，进行语义优化，使计算过程和需要获取的中间数据尽可能少，然后得到数据库的**执行计划**；执行计划交给具体的执行引擎进行计算，将结果通过连接器再返回给应用程序。

SQL-->连接器-->语法分析器-->语义分析与优化器-->执行引擎

## 2、使用PrepareStatement执行SQL的好处

第一：PrepareStatement会预先提交占位符的SQL到数据库进行预处理，提前生成执行计划，当给定占位符参数，真正执行SQL的时候，执行引擎可以直接执行，效率更好一点。

第二：可以防止SQL注入攻击。

加入根据用户名称查询用户功能，页面输入名称，SQL如下：

```
正常输入名称Carol：
select * from user where name ='Carol';
非正常输入Carol';drop table users;--：
select * from user where name = 'Carol';drop table users;--
SQL提交后会被当成两条语句执行
```

使用PrepareStatement，在一开始就已经提交了查询SQL，并被数据库预先生成好的执行计划，后面不管黑客提交什么样的字符串，都只能交给这个执行计划去执行，不可能再生成一条新的SQL语句。

```
select * from user where name = ?
```

## 3、数据库文件存储原理

**为什么索引能加快查询速度？**

数据库索引存储使用B+树。B+树是一种N叉排序树，树的每个节点包含N个数据，这些数据按顺序排好，两个数据之间是一个指向子节点的指针，而子节点的数据在这两个数据大小之间。

![B+树](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\B+树.png)

B+树存储在磁盘上，每个节点存储1000多个数据，树的深度只要四层就能存储数亿的数据。如果将树的根节点缓存在内存中，则最多只需要三次磁盘访问就能倒找索引。

**B+树加快了检索索引的速度，如何通过索引加快查询数据库记录的查询速度呢？**

数据库索引有两种，第一种**聚簇索引**，聚簇索引的数据库记录和索引存储在一起，上面就是聚簇索引的示意，索引1 和记录行r1存储在一起。MySQL数据库的主键就是聚簇索引，主键ID和所在行记录存储在一起。

另一种数据库索引是**非聚簇索引**，非聚簇索引在叶子节点记录的不是数据库行记录，而是聚簇索引，也就是主键。如下图：

![非聚簇索引](D:\WorkSpace\Java\后端面试技术38讲\后端技术面试38讲.assets\非聚簇索引.png)

通过B+树在叶子节点找到非聚簇索引a，和索引a在一起的是主键1，再根据主键1，通过主键（聚簇）索引找到对应的记录，这种通过非聚簇索引找到主键索引，再通过主键索引找到行记录的过程也成为回表。

所以通过索引，可以快速查询到需要的记录，如果要查询的字段上没有索引，就只能扫描整张表了，查询速度慢很多。

## 4、索引是否尽可能的多

索引要合理创建，索引占用物理空间，大量的索引耗费一定的空间；当对表中数据进行增删改的时候，如果有索引，那么索引也要动态的修改，会降低SQL执行效率。

# 七、编程语言原理

